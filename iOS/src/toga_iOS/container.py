from rubicon.objc import objc_method, objc_property, send_super

from .libs import (
    UINavigationController,
    UIView,
    UIViewAutoresizing,
    UIViewController,
)

#######################################################################################
# Implementation notes:
#
# iOS renders everything at 96dpi. Scaling to physical device coordinates is handled
# transparently at all levels, so all coordinates provided by hinting are layout ready,
# and the sizes generated by layout are usable as-is.
#######################################################################################


class TogaContainerView(UIView):
    container = objc_property(object, weak=True)

    @objc_method
    def safeAreaInsetsDidChange(self):
        send_super(__class__, self, "safeAreaInsetsDidChange")
        # Container width and height updated.
        if self.container.on_inset_change:
            self.container.on_inset_change()
        # if self.container._safe_bottom:
        #    self.performSelector(SEL("refreshContent"), withObject=None, afterDelay=0)

    @objc_method
    def refreshContent(self):  # Can't be reliably triggered else in testing cases
        if self.container:  # pragma: no branch
            if self.container.content:
                self.container.content.interface.refresh()

    @objc_method
    def layoutSubviews(self):
        send_super(__class__, self, "layoutSubviews")
        if (
            self.bounds.size.width,
            self.bounds.size.height,
        ) != self.container.last_refreshed_size and self.container.resize_refresh:
            self.container.last_refreshed_size = (
                self.bounds.size.width,
                self.bounds.size.height,
            )
            self.refreshContent()


class BaseContainer:
    def __init__(self, content=None, on_refresh=None, safe_bottom=False):
        """A base class for iOS containers.

        :param content: The widget impl that is the container's initial content.
        :param on_refresh: The callback to be notified when this container's layout is
            refreshed.
        """
        self._content = content
        self.on_refresh = on_refresh
        self._safe_bottom = safe_bottom
        self.un_top_offset_able = 0
        self.additional_top_offset = 0
        self._automatic_un_top_offset_able = True
        self.on_inset_change = None
        self.resize_refresh = False

        self.last_refreshed_size = (0, 0)

    @property
    def content(self):
        """The Toga implementation widget that is the root content of this container.

        All children of the root content will also be added to the container as a result
        of assigning content.

        If the container already has content, the old content will be replaced. The old
        root content and all it's children will be removed from the container.
        """
        return self._content

    @content.setter
    def content(self, widget):
        if self.content:
            self._content.container = None

        self._content = widget
        if widget:
            widget.container = self

    def refreshed(self):
        self.on_refresh(self)

    @property
    def additional_top_offset(self):
        return self._additional_top_offset

    @additional_top_offset.setter
    def additional_top_offset(self, value):
        self._additional_top_offset = value

    #        if self.native:
    #            self.native.refreshContent()

    @property
    def un_top_offset_able(self):
        if self._automatic_un_top_offset_able:
            return 0
        return self._un_top_offset_able

    @un_top_offset_able.setter
    def un_top_offset_able(self, value):
        self._automatic_un_top_offset_able = False
        self._un_top_offset_able = value

    def update_un_top_offset_able(self):
        pass


#        if self.native:
#            self.native.refreshContent()


class Container(BaseContainer):
    def __init__(
        self, content=None, layout_native=None, on_refresh=None, safe_bottom=False
    ):
        """
        :param content: The widget impl that is the container's initial content.
        :param layout_native: The native widget that should be used to provide size
            hints to the layout. This will usually be the container widget itself;
            however, for widgets like ScrollContainer where the layout needs to be
            computed based on a different size to what will be rendered, the source of
            the size can be different.
        :param on_refresh: The callback to be notified when this container's layout is
            refreshed.
        :param safe_bottom: Whether the container should not extend into bottom
            safe area insets.
        """
        self.native = TogaContainerView.alloc().init()
        self.native.container = self
        self.native.translatesAutoresizingMaskIntoConstraints = True
        self.native.autoresizingMask = (
            UIViewAutoresizing.FlexibleWidth | UIViewAutoresizing.FlexibleHeight
        )

        self.layout_native = self.native if layout_native is None else layout_native
        self.scroll_safe = False

        super().__init__(
            content=content, on_refresh=on_refresh, safe_bottom=safe_bottom
        )

    def __del__(self):
        # Mark the contained native object as explicitly None so that the
        # constraints know the object has been deleted.
        self.native = None

    @property
    def width(self):
        if self.scroll_safe:
            return (
                self.layout_native.bounds.size.width
                - self.layout_native.adjustedContentInset.left
                - self.layout_native.adjustedContentInset.right
            )
        return self.layout_native.bounds.size.width

    @property
    def height(self):
        if self.scroll_safe:
            return (
                self.layout_native.bounds.size.height
                - self.layout_native.adjustedContentInset.top
                - self.layout_native.adjustedContentInset.bottom
            )
        if self._safe_bottom:
            return (
                self.layout_native.bounds.size.height
                - self.top_offset
                - self.layout_native.safeAreaInsets.bottom
            )
        else:
            return self.layout_native.bounds.size.height - self.top_offset

    @property
    def top_offset(self):
        return self.additional_top_offset


class ControlledContainer(Container):
    def __init__(
        self,
        content=None,
        layout_native=None,
        on_refresh=None,
        safe_bottom=False,
    ):
        """
        :param content: The widget impl that is the container's initial content.
        :param layout_native: The native widget that should be used to provide
            size hints to the layout. This will usually be the container widget
            itself; however, for widgets like ScrollContainer where the layout
            needs to be computed based on a different size to what will be
            rendered, the source of the size can be different.
        :param on_refresh: The callback to be notified when this container's layout is
            refreshed.
        :param safe_bottom: Whether the container should not extend into bottom
            safe area insets.
        """
        super().__init__(
            content=content,
            layout_native=layout_native,
            on_refresh=on_refresh,
            safe_bottom=safe_bottom,
        )

        # Construct a ViewController that provides a navigation bar, and
        # is able to maintain a stack of navigable content. This is initialized
        # with a root UIViewController that is the actual content
        self.controller = UIViewController.alloc().init()

        # Set the controller's view to be the root content widget
        self.controller.view = self.native


class RootContainer(Container):
    def __init__(
        self,
        content=None,
        layout_native=None,
        on_refresh=None,
        safe_bottom=False,
    ):
        """A bare content container.

        This is a container that *doesn't* include a navigation/title bar at the top.

        :param content: The widget impl that is the container's initial content.
        :param layout_native: The native widget that should be used to provide
            size hints to the layout. This will usually be the container widget
            itself; however, for widgets like ScrollContainer where the layout
            needs to be computed based on a different size to what will be
            rendered, the source of the size can be different.
        :param on_refresh: The callback to be notified when this container's layout is
            refreshed.
        :param safe_bottom: Whether the container should not extend into bottom
            safe area insets.
        """
        super().__init__(
            content=content,
            layout_native=layout_native,
            on_refresh=on_refresh,
            safe_bottom=safe_bottom,
        )

        # Construct a UIViewController to hold the root content
        self.controller = UIViewController.alloc().init()

        # Set the controller's view to be the root content widget
        self.controller.view = self.native

    # The testbed app won't instantiate a simple app, so we can't test these properties
    @property
    def top_offset(self):  # pragma: no cover
        if self.native.window():
            return (
                self.native.window().windowScene.statusBarManager.statusBarFrame.size.height
                + self.additional_top_offset
            )
        else:
            return self.additional_top_offset

    @property
    def title(self):  # pragma: no cover
        return self._title

    @title.setter
    def title(self, value):
        self._title = value


class NavigationContainer(Container):
    def __init__(
        self,
        content=None,
        layout_native=None,
        on_refresh=None,
        safe_bottom=False,
    ):
        """A top level container that provides a navigation/title bar.

        :param content: The widget impl that is the container's initial content.
        :param layout_native: The native widget that should be used to provide
            size hints to the layout. This will usually be the container widget
            itself; however, for widgets like ScrollContainer where the layout
            needs to be computed based on a different size to what will be
            rendered, the source of the size can be different.
        :param on_refresh: The callback to be notified when this container's layout is
            refreshed.
        """
        super().__init__(
            content=content,
            layout_native=layout_native,
            on_refresh=on_refresh,
            safe_bottom=safe_bottom,
        )

        # Construct a NavigationController that provides a navigation bar, and
        # is able to maintain a stack of navigable content. This is initialized
        # with a root UIViewController that is the actual content
        self.content_controller = UIViewController.alloc().init()
        self.controller = UINavigationController.alloc().initWithRootViewController(
            self.content_controller
        )

        # Set the controller's view to be the root content widget
        self.content_controller.view = self.native

    @property
    def top_offset(self):
        return (
            #            UIApplication.sharedApplication.statusBarFrame.size.height
            +self.controller.navigationBar.frame.origin.y
            + self.controller.navigationBar.frame.size.height
            + self.additional_top_offset
        )

    @property
    def title(self):
        return self.controller.topViewController.title

    @title.setter
    def title(self, value):
        self.controller.topViewController.title = value

    @property
    def un_top_offset_able(self):
        if self._automatic_un_top_offset_able:
            return self.top_offset
        return self._un_top_offset_able

    @un_top_offset_able.setter
    def un_top_offset_able(self, value):
        self._automatic_un_top_offset_able = False
        self._un_top_offset_able = value
