from __future__ import annotations

import asyncio

import toga
import uvicorn

from .server import app as fastapi_app


class {{{{ cookiecutter.class_name }}}}(toga.App):
    async def cleanup(self, app, **kwargs):
        # Make sure we don't try to clean up before the server is actually running.
        # This is to prevent the server task dangling on app exit.
        if not self.server.started:
            print("APP :     Waiting for the server to finish starting...")
            await self.socket

        print("APP :     Shutting down...")
        await self.server.shutdown()
        return True

    async def wait_for_socket(self):
        # uvicorn doesn't provide a way to wait until the server is running,
        # or to get the auto-allocated port. See:
        # https://github.com/Kludex/uvicorn/issues/761
        print("APP :     Waiting for server socket...")
        while not self.server.started:  # noqa: ASYNC110
            await asyncio.sleep(0.01)

        for server in self.server.servers:
            for socket in server.sockets:
                self.socket.set_result(socket)
                print("APP :     Server is running.")
                return

    def startup(self):
        # Create a uvicorn server on 127.0.0.1, any available port
        config = uvicorn.Config(
            fastapi_app,
            host="127.0.0.1",
            port=0,
            reload=False,
            workers=1,
        )
        self.server = uvicorn.Server(config)
        self.socket = asyncio.Future()

        # Start the server asynchronously
        asyncio.create_task(self.server.serve())
        asyncio.create_task(self.wait_for_socket())

        self.web_view = toga.WebView(on_webview_load=self.on_initial_webview_load)

        self.on_exit = self.cleanup

        self.main_window = toga.MainWindow()
        self.main_window.content = self.web_view

    async def on_running(self):
        # Wait for the socket, then extract host and port.
        await self.socket
        host, port = self.socket.result().getsockname()

        # Point the webview at the internal server.
        self.web_view.url = f"http://{{host}}:{{port}}/"

    def on_initial_webview_load(self, widget, **kwargs):
        # When the first page is loaded, show the main window. Then clear the load
        # handler; we don't want to force re-showing the window on any subsequence
        # page load.
        self.main_window.show()
        self.web_view.on_webview_load = None


def main():
    return {{{{ cookiecutter.class_name }}}}()
