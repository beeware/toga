from __future__ import annotations

from warnings import filterwarnings, warn

# Make sure deprecation warnings are shown by default
filterwarnings("default", category=DeprecationWarning)


class Condition:
    def __init__(self, **properties):
        """A condition describing the values of one or more properties of a style.

        :param properties: Any number of name: value pairs
        """
        self.properties = properties

    def match(self, style, main_name=None):
        # main_name can't be accessed the "normal" way without causing a loop; we need
        # to access the private stored value.
        return all(style[name] == value for name, value in self.properties.items())

    def __str__(self):
        return ";".join(
            [f"{name} = {value}" for name, value in self.properties.items()]
        )


class aliased_property:
    def __init__(self, derive: dict | str, deprecated: bool = False):
        """Create a property that aliases an existing property.

        :param derive: If this is a string, it is the name of the property to
            reference. Otherwise, it is a dicitionary mapping conditions to the correct
            property name to use. If no condition is met, an AttributeError is raised.
        :deprecated: Is this property name deprecated?
        """
        self.derive = derive
        self.deprecated = deprecated

    def __set_name__(self, owner, name):
        self.name = name
        owner._BASE_ALL_PROPERTIES[owner].add(name)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        name = self.derive_name(obj)
        self.warn_if_deprecated(name)

        return obj[name]

    def __set__(self, obj, value):
        if value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        name = self.derive_name(obj)
        self.warn_if_deprecated(name)

        obj[name] = value

    def __delete__(self, obj):
        name = self.derive_name(obj)
        self.warn_if_deprecated(name)

        del obj[name]

    def is_set_on(self, obj):
        name = self.derive_name(obj)
        self.warn_if_deprecated(name)

        return name in obj

    def derive_name(self, obj):
        if isinstance(self.derive, str):
            return self.derive

        for condition, name in self.derive.items():
            if condition.match(obj):
                return name

        conditions = " or ".join([str(condition) for condition in self.derive])
        raise AttributeError(f"'{self.name}' is only supported when {conditions}")

    def warn_if_deprecated(self, name):
        if self.deprecated:
            cls = type(self)
            warn(
                f"{cls}.{self.name} is deprecated. Use {cls}{name} instead.",
                DeprecationWarning,
                stacklevel=3,
            )
