from warnings import filterwarnings, warn

from .validated import validated_property

# Make sure deprecation warnings are shown by default
filterwarnings("default", category=DeprecationWarning)


class Condition:
    def __init__(self, main_value=None, /, **properties):
        """A condition describing the values of one or more properties of a style.

        :param main_value: The value of the "primary" property in question, if any. This
            is used for paired properties to refer to each other.
        :param properties: Any number of name: value pairs
        """
        self.main_value = main_value
        self.properties = properties

    def match(self, style, main_name=None):
        # main_name can't be accessed the "normal" way without causing a loop; we need
        # to access the private stored value.
        if main_name is not None and getattr(style, f"_{main_name}") != self.main_value:
            return False

        return all(style[name] == value for name, value in self.properties.items())

    def __str__(self):
        return ";".join(
            [f"{name} = {value}" for name, value in self.properties.items()]
        )


class aliased_property:
    def __init__(self, other, deprecated=False, condition=None):
        """Create a property that aliases directly to an existing property.

        :param other: The name of the property to alias to
        :deprecated: Is this property name deprecated?
        :param condition: A condition which must accurately describe the style for this
            alias to be valid. If not, any attempt to get, set, or delete this property
            will generate an AttributeError.
        """

        self.other = other
        self.deprecated = deprecated
        self.condition = condition

    def __set_name__(self, owner, name):
        self.name = name
        owner._BASE_ALL_PROPERTIES[owner].add(name)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        self.warn_if_deprecated()
        self.validate(obj)

        return obj[self.other]

    def __set__(self, obj, value):
        if value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        self.warn_if_deprecated()
        self.validate(obj)

        obj[self.other] = value

    def __delete__(self, obj):
        self.warn_if_deprecated()
        self.validate(obj)

        del obj[self.other]

    def warn_if_deprecated(self):
        if self.deprecated:
            warn(
                f"{self.name} is deprecated. Use {self.other} instead.",
                DeprecationWarning,
                stacklevel=3,
            )

    def validate(self, obj):
        if self.condition and not self.condition.match(obj):
            raise AttributeError(
                f"'{self.name}' is only supported when {self.condition}"
            )

    def is_set_on(self, obj):
        self.warn_if_deprecated()
        self.validate(obj)

        return self.other in obj


class paired_property(validated_property):
    def __init__(
        self,
        *constants,
        string=False,
        integer=False,
        number=False,
        color=False,
        initial=None,
        other,
        derive,
        deprecated=False,
    ):
        """Create a property that pairs with an existing validated_property.

        Either property can be the source of truth; only one can be set at a time. If
        property A is accessed while property B is set, the value of A will be derived
        from B.

        :param constants: Explicitly allowable values.
        :param string: Are strings allowed as values?
        :param integer: Are integers allowed as values?
        :param number: Are numbers allowed as values?
        :param color: Are colors allowed as values?
        :param initial: The initial value for the property. If *neither* property has
            been explicitly set, this is what is returned when this one is accessed.
        :param other: The name of the existing property to pair with.
        :param derive: A dictionary of mutually exclusive Conditions describing the
            other property's value, mapping onto the resulting value for this property.
            A 1-to-1 reverse mapping is automatically generated for the other associated
            property.
        :param deprecated: Is this property name deprecated?
        """
        super().__init__(
            *constants,
            string=string,
            integer=integer,
            number=number,
            color=color,
            initial=initial,
        )
        self.other = other
        self.derive = derive
        self.deprecated = deprecated

    def __set_name__(self, owner, name):
        self.name = name
        if not self.deprecated:
            owner._BASE_PROPERTIES[owner].add(name)
        owner._BASE_ALL_PROPERTIES[owner].add(name)

        # Replace the validated_property of other with another instance of
        # paired_property.

        original_other = getattr(owner, self.other)
        new_other = paired_property(
            *original_other.choices.constants,
            string=original_other.choices.string,
            integer=original_other.choices.integer,
            number=original_other.choices.number,
            color=original_other.choices.color,
            initial=original_other.initial,
            other=self.name,
            derive={
                Condition(result, **condition.properties): condition.main_value
                for condition, result in self.derive.items()
            },
        )

        # We only want to set the name, not actually call __set_name__ and cause a loop.
        new_other.name = self.other

        setattr(owner, self.other, new_other)

    def __get__(self, obj, objtype=None):
        if obj is None:
            return self

        self.warn_if_deprecated()

        if not hasattr(obj, f"_{self.name}"):
            if hasattr(obj, f"_{self.other}"):
                for condition, value in self.derive.items():
                    if condition.match(obj, main_name=self.other):
                        return value

            return self.initial

        return super().__get__(obj)

    def __set__(self, obj, value):
        if value is self:
            # This happens during autogenerated dataclass __init__ when no value is
            # supplied.
            return

        self.warn_if_deprecated()

        try:
            delattr(obj, f"_{self.other}")
        except AttributeError:
            pass
        super().__set__(obj, value)

    def __delete__(self, obj):
        self.warn_if_deprecated()

        try:
            delattr(obj, f"_{self.other}")
        except AttributeError:
            pass
        super().__delete__(obj)

    def is_set_on(self, obj):
        self.warn_if_deprecated()

        return super().is_set_on(obj) or hasattr(obj, f"_{self.other}")

    def warn_if_deprecated(self):
        if self.deprecated:
            warn(
                f"{self.name} is deprecated. Use {self.other} instead.",
                DeprecationWarning,
                stacklevel=3,
            )
